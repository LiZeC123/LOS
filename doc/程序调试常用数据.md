




内存主要代码起始位置
------------------------------

在进入分页模式之前, 可以在如下位置设置断点

0xc00  loader代码起始位置
0xcdd 保护模式代码起始位置
0xcfa 加载内核起始代码
0xd60 内核起始代码

进入分页模式后, 将物理内存最低的1M映射到了0xc000_0000处, 由于对虚拟地址打断点比较麻烦, 因此还是可以直接在物理地址上设置断点. 

例如想要对虚拟地址为0xc0001b2e设置断点, 则可以直接对物理地址0x1b2e设置断点.


使用如下的指令查看一块内存区域的值:

x /50bx 0x00070000




内存
---------------

内核加载过程中将物理内存最低的1M映射到0xc000_0000处.

物理内存中, 从1M位置开始分配了页表, 其中
- 页目录表占据4K, 即 0x10_0000 ~ 0x10_1000 
- 映射内核1M的页表, 占据4K, 0x10_1000 ~ 0x10_2000
- 对内核空间提前分配空间, 分配0x100 - 2项, 每项4K
- 综上, 包括页目录在内, 总计分配0x100个页表, 占据0x100 * 4K = 1M空间

因此物理内存中, 从2M开始为可用空间

内存管理相关的数据结构起始位置: 0xc009_a000 

当前配置下, 一共有32M可用内存, 扣除内核的1M和页表的1M,  内核和用户各自可用15(0xf)M, 其中
内核起始位置为2(0x2)M, 用户起始位置为17(0x11)M



硬盘各扇区内容
----------------------

mbr        起始位置0x0000  第0扇区
loader     起始位置0x0400  第2扇区~第5扇区
kernel     起始位置0x1200  第9扇区


使用类似如下的指令查看硬盘内的数据

```
hexdump -C -n10240 hd60M.img 
```

> hexdump会自动折叠全部为0的数据


常见16进制数据转换
-----------------------------

0x100         =>  256 => 64个4B
0x400         => 1024 =>  1K
0x1000        => 4096 ==> 4K
0x1_0000      =>  64K
0x10_0000     =>   1M
0x100_0000    =>  16M
0x1000_0000   => 256M
0x1_0000_0000 =>   4G


反汇编文件
------------------

以Intel格式反汇编可执行段的内容

objdump -d kernel.bin -M intel > a.txt


------------------

GP异常

sba 19970129
show 
sba 58583045


sba 5898950

lb 0xc000159f

lb 0xc0002520

x /50bx 0xc0101d70

x /50bx 0xc0101d70

~~未知原因导致的中断栈内数据异常, 导致将代码段地址作为ebp的值从栈中弹出, 引发GP异常.~~


中断返回没有问题, 栈里面的数据看起来也没有问题, 但是pop操作触发了GP异常

所以理论上来说, 这是段设置的问题.

GP异常就是段错误, 所以肯定是哪里的设置有问题, 如果地址没有问题, 那就是设置有问题.

1. 从内核申请内存空间的代码是否有问题? 是不是可以访问?
2. 再回顾一遍代码
3. 出问题的地方是从中断返回, 是进入了那个中断? 是否是切换的时候寄存器设置不对导致的? 和fs寄存器是否有关?
4. 或者其实没有问题, 只是某个需要加锁的地方没有正确的加锁?

从现象观察, 应该和参数入栈的方式有关, 其中可能存在某些BUG.