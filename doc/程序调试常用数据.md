




内存主要代码起始位置
------------------------------

在进入分页模式之前, 可以在如下位置设置断点

0xc00  loader代码起始位置
0xcdd 保护模式代码起始位置
0xcfa 加载内核起始代码
0xd60 内核起始代码

进入分页模式后, 将物理内存最低的1M映射到了0xc000_0000处, 由于对虚拟地址打断点比较麻烦, 因此还是可以直接在物理地址上设置断点. 

例如想要对虚拟地址为0xc0001b2e设置断点, 则可以直接对物理地址0x1b2e设置断点.


使用如下的指令查看一块内存区域的值:

x /50bx 0x00070000




内存
---------------

内核加载过程中将物理内存最低的1M映射到0xc000_0000处.

物理内存中, 从1M位置开始分配了页表, 其中
- 页目录表占据4K, 即 0x10_0000 ~ 0x10_1000 
- 映射内核1M的页表, 占据4K, 0x10_1000 ~ 0x10_2000
- 对内核空间提前分配空间, 分配0x100 - 2项, 每项4K
- 综上, 包括页目录在内, 总计分配0x100个页表, 占据0x100 * 4K = 1M空间

因此物理内存中, 从2M开始为可用空间

内存管理相关的数据结构起始位置: 0xc009_a000 

当前配置下, 一共有32M可用内存, 扣除内核的1M和页表的1M,  内核和用户各自可用15(0xf)M, 其中
内核起始位置为2(0x2)M, 用户起始位置为17(0x11)M



硬盘各扇区内容
----------------------

mbr        起始位置0x0000  第0扇区
loader     起始位置0x0400  第2扇区~第5扇区
kernel     起始位置0x1200  第9扇区


使用类似如下的指令查看硬盘内的数据

```
hexdump -C -n10240 hd60M.img 
```

> hexdump会自动折叠全部为0的数据


常见16进制数据转换
-----------------------------

0x100  => 256 => 64个4B
0x1000 => 4096 ==> 4K
0x1_0000 => 64K
0x10_0000 ==> 1M
0x100_0000 ==> 16M
0x1000_0000 ==> 256M
0x1_0000_0000 ==> 4G


反汇编文件
------------------

以Intel格式反汇编可执行段的内容

objdump -d kernel.bin -M intel > a.txt