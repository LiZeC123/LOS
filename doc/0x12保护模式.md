保护模式
============

保护模式是一种CPU的执行模式, 在保护模式之前的CPU运行模式称为实模式. 在实模式下, 所有代码都具有同样的权限, 可以随意的访问任何的内存位置, 进行任何的操作. 因此容易出现一个程序的故障导致整个系统不可用的问题.

在保护模式下, CPU会对代码的内存访问行为进行检查, 当代码错误的访问内存时会抛出对应的异常.

全局描述符
---------------

为了实现保护模式, CPU引入了全局描述符表(Global Descriptor Table, GDT). GDT记录了不同的段的基本属性, 从而能够对段的访问行为进行控制. 当不符合要求的行为出现时, CPU能够自动检测并抛出异常.

全局描述符表在内存中实际就是一个数组, 其中的每个元素都是一个段描述符, 段描述符占8个字节, 其结构如下所示

![段描述符结构](images/段描述符结构.png)

其中8字节可以分为低位4字节和高位4字节. 

### 基地址和段限长

基地址就是这个段实际的物理地址位置. 为了提高转换效率, CPU完成拼接操作后, 会将基地址缓存到寄存器中,后续再使用时能够直接从缓存获取.

>  由于历史兼容性问题, 基地址被分成了三个部分. 

段限长是这个端的最大长度, 一共有20位. 根据其基本单位的长度, 可以表示1MB长度(单位为1字节)或者4GB长度(单位为4KB). 基本长度单位由G位指示. G为取值为1时表示基本长度为4KB, 否则基本长度为1字节.

### S字段和字段类型

S字段取值为1是表示该段为系统段, 取值为0时表示该段为数据段. 不同S取值时, TYPE段具有不同的含义. 当S指示为数据段时, TYPE段可以分为四个属性, 具体情况如下表


内存段类型  | X | R | C | A | 说明                      |内存段类型  | X | W | E | A | 说明
-----------|---|---|---|---|--------------------------|-----------|---|---|---|---|--------------------------
代码段      | 1 | 0 | 0 | * | 只可执行代码              |数据段      | 0 | 0 | 0 | * | 只读数据
代码段      | 1 | 1 | 0 | * | 可读可执行代码            |数据段      | 0 | 1 | 0 | * | 可读可写数据
代码段      | 1 | 0 | 1 | * | 可执行一致性代码          |数据段      | 0 | 0 | 1 | * | 只读向下扩展数据
代码段      | 1 | 0 | 0 | * | 可读可执行一致性代码      |数据段      | 0 | 1 | 1 | * | 可读可写向下扩展数据


- 段默认向上扩展, 但栈需要向下扩展, 因此栈对应的段需要将E位设置为1.
- A表示Access, CPU访问改段后会自动将其置位1


### DPL字段

DPL字段表示该段的特权等级, 该字段有2bit, 因此可以表示四种特权等级. 数字越小, 特权等级越高, 一般操作系统使用0特权等级, 用户代码使用3特权等级.

> 设置不同的特权等级, 即可将操作系统代码和用户代码区分开

### P字段

P字段表示段是否存在于内存之中, 如果为0则CPU访问时抛出相应的异常, 操作系统需要捕获该异常并进行适当的处理.

> 开启分页模式后, 基本上就不会按照字段换出内存了

### D/B字段和L字段

D/B字段指示操作数大小, 取值为1时表示以32位模式运行, 取值为0时表示以16位模式运行.

L指示代码段类型, 取值为1表示64位代码模式运行, 取值为0表示以32位代码模式运行.

### AVL字段

该字段保留


GDT表的内存表示
--------------------

在LOS项目中, GDT表在内存中的结构如下:

```s
section loader vstart=LOADER_BASE_ADDR
LOADER_STACK_TOP equ LOADER_BASE_ADDR
  ; GDT表开始的位置, 第0行为空
  GDT_BASE: dd 0x0000_0000
            dd 0x0000_0000
  ; GDT表第一项, 存储代码段相关属性
  CODE_DESC: dd 0x0000_FFFF
             dd DESC_CODE_HIGH4

  DATA_STACK_DESC: dd 0x0000_FFFF
                   dd DESC_DATA_HIGH4

  VIDEO_DESC: dd 0x8000_0007      ; 显存的位置是0xb80000, 因此低位设置为0x8000, 第二段基地址设置为0xb
                                  ; 32KB显存可以分为8个4K, 从0开始计数, 因此段限长设置为0x7
              dd DESC_VIDEO_HIGH4


  ; 使用空白预留60个表项的空间
  times 60 dq 0
```




GDTR寄存器
--------------------

GDT记录了所有的段信息, 这些信息也存储在内存之中, 因此CPU需要知道GDT在内存中的位置. 对此, CPU提供了一个专门的寄存器GDTR. 

该寄存器长度为6字节, 其中低位的2字节存储段限长, 相当于GDT表占据内存空间的字节数-1, 高位的4字节存储GDT内存的起始地址. 

> 限长字段16bit可以表示65535字节, 每个段描述符占8字节, 因此最多可以存储8192个段

```s
  ; ...
  
  GDT_SIZE  equ $ - GDT_BASE
  GDT_LIMIT equ GDT_SIZE - 1
  
  ; ...

  ; GDT指针, 与GDTR寄存器的内容一致, 低2字节为LIMIT值, 高4字节为地址值
  gdt_ptr dw GDT_LIMIT
          dd GDT_BASE
```

选择子
--------------

在实模式下, 段寄存器表示的是段开始的位置, 在保护模式下, 这些寄存器不再表示地址, 而是表示选择子. 

选择子的0~1位表示特权等级, 第2位是TI位表示数据是存储在GDT中还是LDT中. 剩余的13位表示数据在GDT中的索引.

> 13bit最多可以表示8192个数据, 正好和GDT最大段数量吻合

在保护模式中, 寄存器已经是32位的, 因此此时进行地址访问时, 仅需要将选择子对应的GDT项中的基址与寄存器内的地址相加, 就可以得到要访问的地址.

例如选择子为0x8, 则可知低位3bit均为0, 表示了特权等级和TI. 高13bit的值为0x1, 表示GDT中的第一项(通常第0项不可用). 假设GDT中第1项的基址为0x1234, 当前的偏移地址为0x9, 则对应的实际地址为0x123d.

> GDT第0项不可用的原因与内存低区不可用一样, 当选择子未初始化时访问了GDT可以被感知到, 从而抛出异常.



进入保护模式
---------------

进入保护模式需要完成三件事情

1. 建立GDT表
2. 打开A20地址线
3. 打开保护模式开关

完成上述三个操作后, CPU就会从实模式切换到保护模式. 由于CPU内部使用了流水线, 因此切换到保护模式后还需要使用跳转指令修改CS的值, 使得CPU清空流水线中已经译码的指令.
