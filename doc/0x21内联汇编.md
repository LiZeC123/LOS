内联汇编
==============

在内核加载器完成内核加载操作后, 内核的代码就可以通过C语言实现. 但有部分底层操作由于设计特定端口读写, 因此还是只能通过汇编实现. 为了避免大范围的引入汇编文件, C编译器提供了内联汇编支持. 可在函数内使用汇编代码实现特定功能, 并将其封装为C语言函数.

基本内联汇编
---------------

最基本的内联汇编语句使用方式如下所示:


```c
__asm__ [__volatile__] ("assembly code");
```

其中`__asm__`宏表示后续给定的字符串为汇编代码, `__volatile__`宏用来说明不要对其中的内联代码进行优化.

对于GCC编译器, 其汇编代码仅支持AT&T格式. 通常情况下, 计算机的汇编语言课程仅讲解Intel格式的汇编代码, 因此对于AT&T格式可能较为陌生. 两种格式的主要区别如下:


区别        | Intel格式             | AT&T格式          | 说明
------------|----------------------|-------------------|--------------------------------------------
寄存器      | eax                   | %eax              | Intel格式无前缀, AT&T格式始终使用%前缀
立即数      | 6                     | $6                | Intel格式中数字就是数字
内存地址    | [0x1234]              | 0x1234            | AT&T格式格式中数字默认是地址
操作数大小  | 使用数据类型修饰符     | 指令后最后一个字母  | `mov byte[0x123], eax` `movb eax, 0x123`

两种格式的主要差别如下:
- 在Intel格式中, 指令顺序为`op dst, src`. AT&T格式相反, 为`op src, dst`
- 在Intel格式中, 数字就是立即数, 如果表示内存地址, 需要使用`[]`. 而AT&T格式相反, 数字就是内存地址, 如果表示立即数, 需要使用`$`前缀.

------------------

对于内存寻址操作, AT&T采用如下的通用模式:

```
segreg （段基址） : base address( offset_address,index,size)
```

这等价于Intel格式中的如下模式:

```
greg: [base+index * size+offset]
```

基于AT&T的通用模式可有如下的几种常用模式

寻址模式        | 实例                              | 说明
---------------|-----------------------------------|--------------------------------------------
直接寻址        | `0x1234`, `var`                   | 直接使用内存地址或者变量名
寄存器间接寻址  | `(%eax)`                          | exa占据offset_address部分, 因此具有一个括号
寄存器相对寻址  | `-4(%eax)`                        | offset_address必须为通用寄存器
基址变址寻址    | `(,%esi, 2)`, `(%ebx, %esi, 2)`   | size仅可取值1, 2, 4, 8


在上述模式中, `offset_address`和`index`要求必须为8个通用寄存器之一.

扩展内联汇编
---------------

基础的内联汇编功能较为薄弱, 且应用变量时必须为全局变量. 因此在实际使用过程中, 基本上不会使用基本格式的内联汇编, 而是采用如下的扩展方式, 为代码提供一些额外信息. 其格式为

```c
__asm__ [__volatile__] ("assembly code": output : input : clobber/modify);
```

其中包括汇编代码在内的每个部分都可以为空,  但除了最后一部分以外, 各部分内容为空时不可省略`:`. 即`clobber/modify`部分为空可省略`input`后的`:`, 但仅`input`部分为空时不可省略`output`之后的`:`.


### 寄存器约束

使用寄存器约束可以要求将指定的变量放入指定的寄存器之中. 其中`a`, `b`, `c`, `d`分别表示`eax`, `ebx`, `ecx`, `edx`寄存器, `D`和`S`分别表示`edi`和`esi`寄存器. `q`表示四个基本寄存器中的任意一个, `r`表示六个寄存器中的任意一个, `g`表示可以存储在寄存器或内存的任意位置. `m`表示数据应该存储在内存之中.

例如对于如下的内联汇编代码:

```c
int main() {
  int in_a = 1, in_b = 2, out_sum;
  __asm__ __volatile__ ("addl %%ebx, %%eax": "=a"(out_sum): "a"(in_a),"b"(in_b));
  printf("sun is %d\n", out_sum);
}
```

希望将in_a放入eax变量, 将in_b放入ebx变量, 执行`add`操作后, 将`eax`的结果写入`out_sum`变量. 对应的汇编指令如下


```
11ee:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
11f5:	c7 45 f0 02 00 00 00 	movl   $0x2,-0x10(%ebp)
11fc:	8b 45 ec             	mov    -0x14(%ebp),%eax
11ff:	8b 4d f0             	mov    -0x10(%ebp),%ecx
1202:	89 cb                	mov    %ecx,%ebx
1204:	01 d8                	add    %ebx,%eax
1206:	89 45 f4             	mov    %eax,-0xc(%ebp)
```

注意: 上述的内联汇编代码中, 使用寄存器时使用的是`%%eax`, 有两个`%`. 这是因为在内联汇编中使用`%`作为占位符, 除了可以引用寄存器外, 也可以使用数字占位符, 例如`%1`, `%2`等. 因此上述汇编代码也可以写为

```c
__asm__ __volatile__ ("addl %2, %1": "=a"(out_sum): "a"(in_a),"b"(in_b));
```

按照约束从左到右的顺序, `out_sum`对应占位符为`%0`, in_a占位符为`%1`且已经约束为使用`%eax`, in_b占位符为`%2`且已经约束为使用`%ebx`.


### 变更声明

在扩展内联汇编的最后一个部分是`clobber/modify`, 用于告知GCC本次内联汇编修改了那些内容, 以便于GCC检测修改是否和外部的C代码产生冲突. 

此部分的取值较为简单, 修改了那些寄存器, 则直接写对应寄存器的名字即可. 例如

```c
__asm__ __volatile__ ("movl %%eax, %0 ;movl %%eax,%%ebx": "=m"(ret_value)::"bx")
``

由于寄存器的任意一个部分被修改, 则相当于整个寄存器被修改. 因此声明`bx` 就等于声明`bl`, `bh`, `ebx`等寄存器被修改.

---------------

此外, 还可以使用`memory`表明对内存进行了修改, 使得GCC放弃寄存器缓存值. 通常情况下, GCC会对一部分内存中的数据, 存储到寄存器中, 以便于提升访问速度. 在内存值发生变换的情况下, 继续使用缓存值将会导致错误的结果.
