位图
--------

在内存管理时, 为了能够以较小的内存空间消耗管理较多的内存, 引入了位图数据结构. 在位图中, 使用1个bit表示一个内存页是否被使用.

位图的实现可以查看[kernel/bitmap.h](../kernel/bitmap.h)以及[kernel/bitmap.c](../kernel/bitmap.c). 实现非常简单直接, 不再赘述其逻辑. 在[test/test_bitmap.c](../test/test_bitmap.c)中包含了对其的基本功能测试.


内存池规划
-----------

在启用虚拟内存地址后, 对于任意一个进程, 均可以使用4GB的内存空间. 在进程申请新的内存空间时, 操作系统需要记录虚拟地址空间和实际物理空间的使用情况, 以确保内存分配过程不出现问题.


### 当前内存布局

在loader.S加载内核代码时, 进行了规划, 将最低1M空间作为存放内核代码和数据的空间, 因此1M以内的空间均视为已经使用的空间, 不可被分配.

并且这1M内存空间已经进行了内存映射, 即

```
0x00000000-0x000fffff -> 0x000000000000-0x0000000fffff
0xc0000000-0xc00fffff -> 0x000000000000-0x0000000fffff
```

直接使用0x00000000或者0xc0000000开始的虚拟地址均可访问这1M内存空间的数据.

-------------

在loader.S创建页表相关数据时, 从1M内存开始, 存放了页表相关数据, 其中: 1个页目录表(1页)+页目录第0项和第0x301项指向的页表(1页)+内核空间245项页目录项指向的页表(254页), 正好也使用了256 * 4K = 1M 空间.

在当前配置下, 一共有32M可用内存, 扣除内核的1M和页表的1M, 将剩余的内存空间分割为两个相等大小的部分, 即内核和用户各自可用15(0xf)M, 其中内核起始位置为2(0x2)M, 用户起始位置为17(0x11)M


### 内核虚拟地址起始位置

在loader.S创建页表相关数据时, 虚拟地址从 0xC000_0000 ~ 0xC00F_FFFF 的1M空间已经进行了映射, 因此相邻的下一个可用虚拟地址为0xC010_0000. 可将该地址作为内核空间的虚拟地址起始地址.

注意: 虚拟地址并不和物理地址保持一致的连续性. 在当前内存中, 物理地址 0x0010_0000 位置已经存放了页表数据, 后续对内核空间分配内存时, 对于虚拟地址 0xC010_0000 需要映射到其他位置止.


### 位图存储位置

在当前内核中, 代码被加载到0xC000_1500, 并且将esp设置为0xC009_F000. 实际上, 内核作为一个进程需要一个PCB块. 一个PCB块占据1页内存空间. 因此0xC009_E000 ~ 0xC009_EFFF的内存空间作为PCB块.

在当前的位图模式下, 1页内存可表示 4K * 8 * 4K = 128M 空间, 出于扩展性考虑, 从0xC009_E00向下的4页内存空间作为位图的空间, 使得最多可支持 128 * 4 = 512M 空间. 因此位图的起始位置设置为0xC009_A000


页表操作
-----------

在进行内存分配时, 同时也需要对页表相关的数据进行操作, 使得虚拟地址和物理地址实现映射. 为了便于操作, 可先定义两个宏

```c
#define PDE_IDX(addr) ((addr & 0xffc00000) >> 22)
#define PTE_IDX(addr) ((addr & 0x003ff000) >> 12)
```

给定一个虚拟地址, 可使用上述的两个宏获取对应的页目录项索引和页表项索引. 相关定义可回顾[0x14内存分页](0x14内存分页.md)中的相关内容.


### 获取虚拟地址对应的页目录项地址

给定一个虚拟地址, 如果想要对该地址的页目录项进行修改, 则需要计算出对应的页目录项的虚拟地址, 其实现如下:

```c
uint32_t *pde_ptr(uint32_t vaddr) {
  return (uint32_t *)(0xfffff000 + PDE_IDX(vaddr) * 4);
}
```

对于上述返回的地址, 其最高10bit为0x3ff, 因此找到页目录表的最后一项. 由于在loader.S创建页表相关数据结构时, 将页目录项的最后一项指向了页目录表本身, 因此之后将页目录表当做页表进行查询.

上述地址的中间10bit依然为0x3ff, 依然指向页目录表最后一项. 因此之后将页目录表所在的1页内存空间视为该虚拟地址对应的物理地址空间.

因此最后将vaddr的页目录索引提取出来并直接乘以4, 即可得到该虚拟地址在页目录表中对应的页目录项的地址.


### 获取虚拟地址对应的页表项地址

给定一个虚拟地址, 如果想要对该地址的页表项进行修改, 则需要计算出对应的页表项的虚拟地址, 其实现如下:

```c
uint32_t *pte_ptr(uint32_t vaddr) {
  return (uint32_t *)(0xffc00000 + ((vaddr & 0xffc00000) >> 10) +
                      PTE_IDX(vaddr) * 4);
}
```

对于上述返回的地址, 其最高10bit的处理逻辑与`pde_ptr`函数一致, 因此之后将页目录表当做页表进行查询. 

中间的10bit为vaddr的页目录项索引, 因此将定位到vaddr在页目录表中的对应项, 从而将vaddr对应的页表所在的1页空间作为虚拟地址对应的物理地址空间. 

最后将vaddr的页表项索引乘以4, 即可得到该虚拟地址在页表中的页表项偏移地址.

### 总结

无论是获取页目录项地址还是页表项地址, 实际上都是一个计算对应的物理地址所处的虚拟地址的过程. 而其中最核心的思路就是页目录表的最后一项指向自己, 从而使页目录表实际上也具有了虚拟地址, 也就是之前在查看页面时看到的映射关系:

```
0xfffff000-0xffffffff -> 0x000000100000-0x000000100fff
```

在理解了页目录项地址的获取过程后, 页表项地址的获取过程也就大同小异了. 







