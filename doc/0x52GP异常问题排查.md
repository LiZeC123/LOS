GP异常问题排查
-------------------

在当前的线程模式下, 如果配置为

```c
  thread_start("Thread-01", 31, k_thread_a, "argA");
  thread_start("Thread-02", 8, k_thread_b, "argB");
```

则与主线程一起, 一共3条线程进行打印时, 可以在较长时间保持正常执行. 但只要随意调整线程的优先级, 例如修改为

```c
  thread_start("Thread-01", 17, k_thread_a, "argA");
  thread_start("Thread-02", 20, k_thread_b, "argB");
```

则在输出少量字符后就会产生错误, 屏幕提示

```
#GP General Protection Exception
```

初步分析
------------

General Protection Exception（通用保护异常）是x86架构的一种异常类型，它表示发生了一个保护性错误，通常是由于特权级别不正确或访问了受保护的内存区域而触发的异常。

以下是一些可能导致通用保护异常的情况：

1. 特权级别错误：当一个任务尝试执行特权级别高于其当前权限的指令或访问特权级别高于其当前权限的资源时，会触发通用保护异常。例如，用户模式的程序尝试执行特权级别为内核模式的指令。

2. 非法指令或操作码：当执行到非法指令或操作码时，可能会引发通用保护异常。这可能是由于软件错误、指令损坏或对特定处理器不受支持的指令进行执行。

3. 内存访问错误：当访问受保护的内存区域时，如没有权限的内存页或不存在的内存页，通用保护异常会被触发。这可能是由于内存访问越界、缺页错误、非法内存访问等引起的。

4. 栈溢出：当栈的大小超过其所分配的内存范围时，可能会触发通用保护异常。这通常是由于递归调用或函数调用层次太深而导致的。

5. 段错误：当使用无效的段选择器、段寄存器或段描述符进行内存访问时，通用保护异常会被触发。这可能是由于段选择器错误、段寄存器错误或段描述符损坏引起的。

- [Exceptions](https://wiki.osdev.org/Exceptions#General_Protection_Fault)
  
  
------------

首先使用`show int`启用中断信息输出, 然后正常执行代码. 记录在产生GP异常后的最后一条中断信息, 使用`sba`设置时间断点, 发现问题的前一条指令是iret, 在iret后执行下一条指令是出现GP异常.

排查选择子和内存地址并未发现异常. 初步分析后并无结论.


问题特征分析
----------------

经过一段时间的DEBUG后, 发现并不能定位具体的问题原因, 因此决定先简化场景, 找到case能复现的最小环境. 经过一些代码测试,  问题的表现总结如下:

1. 如果仅1个线程打印文本, 则执行足够长时间(>30s)不会GP异常
2. 如果仅2个线程打印文本, 则执行一段时间(大约10秒)后会GP异常
    - 调整线程优先级, 会影响出现GP异常的时间, 设置为不同的值, 出现GP异常的时间不一致
3. 如果仅2个线程打印文本, 其余1线程执行非打印操作, 则运行足够长时间(>30秒)不会产生GP异常.
    - 与三个线程的执行顺序无关, 
4. 如果包含3个线程打印文本, 则会产生GP异常
    - 产生时间与线程优先级有关
    - 此时在各线程之间插入非打印线程并不会导致GP异常消失
5. 如果2个线程执行非文本操作, 主线程执行打印操作, 则执行足够长时间(>30s)不会GP异常
6. 如果3个线程打印文本, 在特定的优先级比例下, 可运行足够长时间(>30s)不会GP异常

--------------------------

综合以上线索可以得到如下结论
1. GP异常问题与屏幕输出相关性较大, 与线程切换相关性不大.
2. 2个线程打印, 1个现场执行其他操作时, 不会产生GP异常, 该表现的原因需要深入分析.
3. 3个线程打印, 会较快产生GP异常, 且此时插入其他非打印现场并不会导致问题消失.
4. 从线程数量上考虑, 应该与线程本身的内存分配关联不大
    - 两个非打印线程可长时间正常执行, 而两个打印线程会较快产生GP异常

--------------------------

结论:
1. 屏幕打印设计加锁和解锁操作. 理论上不应该产生并发问题.  可优先检查这一部分代码的情况


锁与并发问题排查
----------------------

从GP异常的表现来看, 与屏幕输出关联较大, 而屏幕输出时会使用锁机制. 其中会产生线程阻塞与回复的代码. 从代码DEBUG情况分析, 由中断返回产生异常, 可能是中断的开关设置不正确间接导致的问题.

初步分析认为: 由于线程阻塞操作时开关中断的操作不匹配, 因此设计信号量相关的代码可能出现非原子操作, 导致在不合适的位置被中断, 进而导致后续代码异常.



问题结论
-----------

由于此问题仅在多线程同时写入屏幕(或者可能是多线程并发获取锁)时, 以一定概率出现, 因此暂不深入分析具体原因, 如果后续再次遇到此问题, 则做进一步的深入分析.


最终结论
------------

根据[这篇博客](https://www.kn0sky.com/?p=47#%E8%BF%90%E8%A1%8C-bochs-1)的描述, 在启用时钟中断后, Bochs似乎有一定概率触发其他类型的中断, 并且由于未设置中断处理函数, 导致进入错误代码位置, 并最终触发GP异常.

因此该作者手动添加了若干中断处理函数, 从而修复了该问题.

在本项目的后续开发过程中, 扩展了中断处理函数范围, 支持到了0x30. 此时再次测试上述多线程输出时, 确实不再触发GP异常. 因此暂且认为是相同原因导致GP异常问题.