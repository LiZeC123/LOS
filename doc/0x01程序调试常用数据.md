程序调试常用数据
======================


16进制转换表
----------------

在操作系统开发和调试过程中, 经常设计按位操作, 此时使用16进制更为方便, 一些常见的16进制转换关系如下


0x100         =>  256 => 64个4B
0x400         => 1024 =>  1K
0x1000        => 4096 ==> 4K
0x1_0000      =>  64K
0x10_0000     =>   1M
0x100_0000    =>  16M
0x1000_0000   => 256M
0x1_0000_0000 =>   4G 



内存主要代码起始位置
------------------------------

在进入分页模式之前, 可以在如下位置设置断点

0xc00  loader代码起始位置
0xcdd 保护模式代码起始位置
0xcfa 加载内核起始代码
0xd60 内核起始代码

进入分页模式后, 将物理内存最低的1M映射到了0xc000_0000处, 由于对虚拟地址打断点比较麻烦, 因此还是可以直接在物理地址上设置断点. 

例如想要对虚拟地址为0xc0001b2e设置断点, 则可以直接对物理地址0x1b2e设置断点.



内存
---------------

内核加载过程中将物理内存最低的1M映射到0xc000_0000处.

物理内存中, 从1M位置开始分配了页表, 其中
- 页目录表占据4K, 即 0x10_0000 ~ 0x10_1000 
- 映射内核1M的页表, 占据4K, 0x10_1000 ~ 0x10_2000
- 对内核空间提前分配空间, 分配0x100 - 2项, 每项4K
- 综上, 包括页目录在内, 总计分配0x100个页表, 占据0x100 * 4K = 1M空间

因此物理内存中, 从2M开始为可用空间

内存管理相关的数据结构起始位置: 0xc009_a000 

当前配置下, 一共有32M可用内存, 扣除内核的1M和页表的1M,  内核和用户各自可用15(0xf)M, 其中
内核起始位置为2(0x2)M, 用户起始位置为17(0x11)M

