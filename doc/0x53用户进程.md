用户进程
============


GDT与LDT
----------------

GDT（全局描述符表）和LDT（局部描述符表）是在x86体系结构中用于管理内存段的数据结构。它们用于存储有关内存段的信息，包括段的基地址、大小、特权级别和访问权限等。

GDT是一个全局的数据结构，用于存储系统中所有任务和进程的段描述符。每个任务或进程都有一个在GDT中对应的段描述符，通过该描述符可以访问内存中的相应段。GDT中的段描述符是全局可见的，可以被系统中的所有任务和进程所共享。

> 由于使用平坦结构, 因此在本系统中全局的段就只剩下代码段, 数据段, 栈段和显存段了, 且对于每个任务来说该取值都是一样的

LDT是一个局部的数据结构，用于存储特定任务或进程的段描述符。与GDT不同，每个任务或进程都有一个独立的LDT。当任务或进程切换时，LDT也会相应地切换。LDT中的段描述符只对特定的任务或进程可见，其他任务或进程无法直接访问。

GDT和LDT的主要区别在于它们的作用范围和可见性。GDT用于存储系统中所有任务和进程的段描述符，是全局可见的，可以被系统中所有任务和进程所访问。而LDT用于存储特定任务或进程的段描述符，是局部的，只对相应的任务或进程可见。


TSS的作用
---------------

TSS（任务状态段）是一个特殊的段，用于存储任务的上下文信息，包括任务的寄存器状态、堆栈指针、I/O许可位图等。当任务切换发生时，当前任务的上下文会保存到其对应的TSS中，然后加载新任务的上下文。

TSS是任务切换的关键组成部分。通过加载不同的TSS，可以切换不同的任务。当任务切换发生时，处理器会自动保存当前任务的上下文到其对应的TSS，并加载下一个任务的上下文。

TSS也用于支持特权级别的切换，例如从用户态切换到内核态。当发生特权级别切换时，处理器会加载相应特权级别的TSS，以确保正确的特权级别和上下文切换。

-------------------

CPU厂商原本计划使用TSS提供任务切换能力, 即对不同的任务创建不同的TSS, 切换任务时只需要切换对应的TSS即可. 但该操作开销太大, 因此在Linux系统中并未采取该方案.

Linux系统依然使用TSS, 但所有任务均共享该TSS. 而且除了TSS中的`esp0`和`ss0`以外, 并不使用其他字段. 这两个字段用户在特权等级切换时,找到0特权级的栈位置.

```c
// 更新 tss 中 esp0 字段的值为 pthread 的 0 级栈
void update_tss_esp(TaskStruct *pthread) {
  tss.esp0 = (uint32_t *)((uint32_t)pthread + PG_SIZE);
}
```

> 并且由于栈选择子并不会变换, 因此每次实际上仅需要更新esp0即可


用户进程的虚拟内存空间
---------------------

用户进程最显著的一个特点是: 每个用户进程均拥有独立的虚拟内存空间, 就好像这个进程独占整个内存. 要实现这一功能实际非常简单, 给每个进程维护一个独立的页表即可.

```c
typedef struct {
  //  ...
  uint32_t *pgdir;            // 进程自己的页表的虚拟地址
  VirtualAddr userprog_vaddr; // 用户进程的虚拟地址
  // ...
} TaskStruct;
```

注意, 这里存储的是虚拟地址. 在系统进入内核代码(即执行main对应的逻辑)前, 在loader.S中通过汇编代码写入了内核的页表信息, 此后进入保护模式, 所有的地址访问均变为虚拟地址访问. 因此在这里也仅能使用虚拟地址. 但由于

1. 所有的进程均将内核空间映射到最高1GB虚拟地址, 因此内核的内存的虚拟地址对所有进程而言都是一致的
2. 用户的页面为了避免被用户访问, 因此在内核空间中分配页表的存储空间

因此`pgdir`使用地址并不会导致无法唯一定位内存的问题.


```c
// 切换页目录表
// 不同进程之间使用不同的页目录表, 因此需要切换CR3寄存器的值
void page_dir_activate(TaskStruct *p_thread) {
  uint32_t pagedir_phy_addr = 0x100000; // 内核线程的默认页目录表地址
  if (p_thread->pgdir != NULL) {
    pagedir_phy_addr = addr_v2p((uint32_t)p_thread->pgdir);
  }

  __asm__ __volatile__("movl %0, %%cr3" ::"r"(pagedir_phy_addr) : "memory");
}
```



特权转移
-----------------

用户进程的另一个特点是运行在低特权等级. 因此用户进程无法执行一些特殊的CPU指令, 从而避免了一个用户的进程错误影响到全局的其他进程.

CPU允许通过中断, 从低特权等级转移到高特权等级. 因此通过中断返回, 即可在从高特权等级返回低特权等级. 执行中断返回时, 会执行一系列pop操作, 将保存的上下文信息重新存入寄存器. 因此与线程的启动逻辑一样, 提前准备好对应的寄存器值, 然后执行中断返回即可.

